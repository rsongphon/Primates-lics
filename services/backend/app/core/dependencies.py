"""
LICS Backend Dependencies

FastAPI dependency injection system providing database sessions,
authentication, authorization, and common utilities. Follows
Documentation.md Section 5.1 dependency injection patterns.
"""

import uuid
from typing import AsyncGenerator, Optional

from fastapi import Depends, HTTPException, Request, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.database import get_db_session, db_manager
from app.core.logging import correlation_context, extract_request_info, get_correlation_id, get_logger

logger = get_logger(__name__)

# Security scheme for JWT authentication
security = HTTPBearer(auto_error=False)


# ===== DATABASE DEPENDENCIES =====

async def get_database_session() -> AsyncGenerator[AsyncSession, None]:
    """
    FastAPI dependency to get database session with proper cleanup.

    This is the primary way to inject database sessions into FastAPI endpoints.

    Usage:
        @app.get("/users/")
        async def get_users(db: AsyncSession = Depends(get_database_session)):
            # Use the session
            pass
    """
    async with db_manager.session_scope() as session:
        yield session


async def get_read_only_session() -> AsyncGenerator[AsyncSession, None]:
    """
    FastAPI dependency to get read-only database session.

    This can be used for read operations that don't require transaction guarantees.

    Usage:
        @app.get("/users/")
        async def get_users(db: AsyncSession = Depends(get_read_only_session)):
            # Use for read operations only
            pass
    """
    async with db_manager.session_scope() as session:
        # Note: In a more complex setup, this could connect to a read replica
        yield session


# ===== REQUEST CONTEXT DEPENDENCIES =====

async def get_request_id(request: Request) -> str:
    """
    Get or generate request ID for correlation tracking.

    Args:
        request: FastAPI request object

    Returns:
        Request correlation ID
    """
    # Check if correlation ID already exists in headers
    correlation_id = request.headers.get("x-correlation-id")
    if not correlation_id:
        # Check if it was generated by middleware
        correlation_id = getattr(request.state, "correlation_id", None)
        if not correlation_id:
            # Generate new correlation ID
            correlation_id = str(uuid.uuid4())
            request.state.correlation_id = correlation_id

    return correlation_id


async def get_request_context(request: Request) -> dict:
    """
    Extract request context information for logging and monitoring.

    Args:
        request: FastAPI request object

    Returns:
        Dictionary with request context information
    """
    correlation_id = await get_request_id(request)
    request_info = extract_request_info(request)

    return {
        "correlation_id": correlation_id,
        "request_info": request_info,
        "user_agent": request.headers.get("user-agent", ""),
        "remote_addr": request.client.host if request.client else "",
        "method": request.method,
        "url": str(request.url),
        "headers": dict(request.headers)
    }


# ===== AUTHENTICATION DEPENDENCIES =====

async def get_current_user_optional(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)
) -> Optional[dict]:
    """
    Get current user from JWT token (optional - returns None if no token).

    Args:
        credentials: HTTP Bearer token credentials

    Returns:
        User information if authenticated, None otherwise
    """
    if not credentials or not credentials.credentials:
        return None

    try:
        # TODO: Implement JWT token decoding and user lookup
        # This is a placeholder implementation
        token = credentials.credentials

        # Decode JWT token
        payload = await decode_jwt_token(token)

        # Get user information
        user_info = await get_user_from_token(payload)

        return user_info
    except Exception as e:
        logger.warning(f"Invalid token provided: {e}")
        return None


async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)
) -> dict:
    """
    Get current user from JWT token (required - raises 401 if no valid token).

    Args:
        credentials: HTTP Bearer token credentials

    Returns:
        User information

    Raises:
        HTTPException: If authentication is invalid or missing
    """
    user = await get_current_user_optional(credentials)

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user


async def get_current_user_id(
    current_user: dict = Depends(get_current_user)
) -> uuid.UUID:
    """
    Get current user ID as UUID.

    Args:
        current_user: Current user information

    Returns:
        User ID as UUID

    Raises:
        HTTPException: If user ID is invalid
    """
    try:
        user_id = current_user.get("id") or current_user.get("user_id")
        if isinstance(user_id, str):
            return uuid.UUID(user_id)
        elif isinstance(user_id, uuid.UUID):
            return user_id
        else:
            raise ValueError("Invalid user ID format")
    except (ValueError, TypeError) as e:
        logger.error(f"Invalid user ID in token: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid user ID in token"
        )


# ===== AUTHORIZATION DEPENDENCIES =====

def require_role(required_role: str):
    """
    Dependency factory to check if user has required role.

    Args:
        required_role: Required role name

    Returns:
        FastAPI dependency function

    Usage:
        @app.get("/admin/")
        async def admin_endpoint(
            current_user: dict = Depends(require_role("admin"))
        ):
            pass
    """
    async def check_role(current_user: dict = Depends(get_current_user)) -> dict:
        user_roles = current_user.get("roles", [])

        if required_role not in user_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Role '{required_role}' required"
            )

        return current_user

    return check_role


def require_permission(required_permission: str):
    """
    Dependency factory to check if user has required permission.

    Args:
        required_permission: Required permission name

    Returns:
        FastAPI dependency function

    Usage:
        @app.get("/devices/")
        async def get_devices(
            current_user: dict = Depends(require_permission("devices:read"))
        ):
            pass
    """
    async def check_permission(current_user: dict = Depends(get_current_user)) -> dict:
        user_permissions = current_user.get("permissions", [])

        if required_permission not in user_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission '{required_permission}' required"
            )

        return current_user

    return check_permission


async def require_admin(current_user: dict = Depends(get_current_user)) -> dict:
    """
    Dependency to require admin role.

    Args:
        current_user: Current user information

    Returns:
        User information if admin

    Raises:
        HTTPException: If user is not admin
    """
    user_roles = current_user.get("roles", [])

    if "admin" not in user_roles and "super_admin" not in user_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin role required"
        )

    return current_user


# ===== PAGINATION DEPENDENCIES =====

async def get_pagination_params(
    skip: int = 0,
    limit: int = 100
) -> dict:
    """
    Get pagination parameters with validation.

    Args:
        skip: Number of items to skip
        limit: Maximum number of items to return

    Returns:
        Dictionary with validated pagination parameters

    Raises:
        HTTPException: If parameters are invalid
    """
    if skip < 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Skip parameter must be non-negative"
        )

    if limit <= 0 or limit > 1000:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Limit parameter must be between 1 and 1000"
        )

    return {"skip": skip, "limit": limit}


async def get_ordering_params(
    order_by: Optional[str] = None,
    order_desc: bool = False
) -> dict:
    """
    Get ordering parameters.

    Args:
        order_by: Field name to order by
        order_desc: Whether to order in descending order

    Returns:
        Dictionary with ordering parameters
    """
    return {"order_by": order_by, "order_desc": order_desc}


# ===== FILTER DEPENDENCIES =====

async def get_filter_params(request: Request) -> dict:
    """
    Extract filter parameters from query string.

    Args:
        request: FastAPI request object

    Returns:
        Dictionary with filter parameters
    """
    filters = {}

    # Extract query parameters that start with 'filter_'
    for key, value in request.query_params.items():
        if key.startswith("filter_"):
            filter_key = key.replace("filter_", "")
            filters[filter_key] = value

    return filters


# ===== UTILITY DEPENDENCIES =====

async def get_settings() -> dict:
    """
    Get application settings.

    Returns:
        Application settings
    """
    return {
        "app_name": settings.APP_NAME,
        "app_version": settings.APP_VERSION,
        "environment": settings.ENVIRONMENT,
        "debug": settings.DEBUG
    }


async def check_health_dependency() -> bool:
    """
    Dependency to check if the service is healthy.

    Returns:
        True if healthy

    Raises:
        HTTPException: If service is unhealthy
    """
    try:
        health_result = await db_manager.health_check()

        if health_result.get("status") != "healthy":
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Service is unhealthy"
            )

        return True
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service health check failed"
        )


# ===== PLACEHOLDER FUNCTIONS FOR JWT =====
# These will be implemented in the authentication module

async def decode_jwt_token(token: str) -> dict:
    """
    Decode and validate JWT token.

    Args:
        token: JWT token string

    Returns:
        Token payload

    Raises:
        Exception: If token is invalid

    Note:
        This is a placeholder implementation.
        Real implementation will be in the auth module.
    """
    # TODO: Implement proper JWT token decoding
    # For now, return a mock payload
    import json
    import base64

    # This is just for testing - DO NOT use in production
    mock_payload = {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "email": "test@example.com",
        "roles": ["user"],
        "permissions": ["devices:read", "experiments:read"]
    }

    logger.warning("Using mock JWT token decoder - implement proper JWT handling")
    return mock_payload


async def get_user_from_token(payload: dict) -> dict:
    """
    Get user information from token payload.

    Args:
        payload: Decoded token payload

    Returns:
        User information

    Note:
        This is a placeholder implementation.
        Real implementation will lookup user in database.
    """
    # TODO: Implement proper user lookup from database
    # For now, return the payload as user info
    logger.warning("Using mock user lookup - implement proper user service")
    return payload


# ===== COMMON DEPENDENCY COMBINATIONS =====

CommonDeps = dict[str, any]


async def get_common_dependencies(
    db: AsyncSession = Depends(get_database_session),
    current_user: Optional[dict] = Depends(get_current_user_optional),
    pagination: dict = Depends(get_pagination_params),
    ordering: dict = Depends(get_ordering_params),
    request_context: dict = Depends(get_request_context)
) -> CommonDeps:
    """
    Get common dependencies used by many endpoints.

    Returns:
        Dictionary with common dependencies
    """
    return {
        "db": db,
        "current_user": current_user,
        "current_user_id": current_user.get("id") if current_user else None,
        "pagination": pagination,
        "ordering": ordering,
        "request_context": request_context
    }


async def get_authenticated_dependencies(
    db: AsyncSession = Depends(get_database_session),
    current_user: dict = Depends(get_current_user),
    current_user_id: uuid.UUID = Depends(get_current_user_id),
    pagination: dict = Depends(get_pagination_params),
    ordering: dict = Depends(get_ordering_params),
    request_context: dict = Depends(get_request_context)
) -> CommonDeps:
    """
    Get dependencies for authenticated endpoints.

    Returns:
        Dictionary with authenticated dependencies
    """
    return {
        "db": db,
        "current_user": current_user,
        "current_user_id": current_user_id,
        "pagination": pagination,
        "ordering": ordering,
        "request_context": request_context
    }